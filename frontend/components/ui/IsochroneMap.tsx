"use client";

import { useEffect, useRef, useState } from "react";
import L from "leaflet";
import "leaflet/dist/leaflet.css";

// Import cached isochrone data (will be generated by script)
let isochroneCache: Record<string, { features: Array<{
  properties: { fill: string; "fill-opacity": number };
  geometry: { coordinates: number[][][]; type: string };
}> }> = {};

// Try to load cache - this will be populated after running the generation script
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  isochroneCache = require("@/lib/isochroneCache.json");
} catch {
  // Cache not generated yet
}

interface NeighbourhoodData {
  lat: number;
  lng: number;
  name: string;
}

interface IsochroneMapProps {
  neighbourhoods: NeighbourhoodData[];
}

// Color schemes for primary and secondary
const colorSchemes = {
  primary: {
    colors: ["#6366f1", "#a855f7", "#ec4899"], // indigo, purple, pink
    marker: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
  },
  secondary: {
    colors: ["#10b981", "#14b8a6", "#06b6d4"], // emerald, teal, cyan
    marker: "linear-gradient(135deg, #10b981 0%, #06b6d4 100%)",
  },
};

export default function IsochroneMap({ neighbourhoods }: IsochroneMapProps) {
  const mapRef = useRef<HTMLDivElement>(null);
  const mapInstanceRef = useRef<L.Map | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!mapRef.current || neighbourhoods.length === 0) return;

    // Clean up existing map
    if (mapInstanceRef.current) {
      mapInstanceRef.current.remove();
      mapInstanceRef.current = null;
    }

    // Calculate center point (average of all neighbourhoods)
    const centerLat = neighbourhoods.reduce((sum, n) => sum + n.lat, 0) / neighbourhoods.length;
    const centerLng = neighbourhoods.reduce((sum, n) => sum + n.lng, 0) / neighbourhoods.length;

    // Initialize map
    const map = L.map(mapRef.current, {
      center: [centerLat, centerLng],
      zoom: 13,
      zoomControl: true,
      scrollWheelZoom: false,
    });

    mapInstanceRef.current = map;

    // Add tile layer (using a light style)
    L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      maxZoom: 19,
    }).addTo(map);

    // Load isochrones for all neighbourhoods
    const loadIsochrones = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const allBounds: L.LatLngBounds[] = [];

        for (let i = 0; i < neighbourhoods.length; i++) {
          const neighbourhood = neighbourhoods[i];
          const scheme = i === 0 ? colorSchemes.primary : colorSchemes.secondary;

          // Add marker
          const markerIcon = L.divIcon({
            className: "custom-marker",
            html: `<div style="
              width: 24px;
              height: 24px;
              background: ${scheme.marker};
              border-radius: 50%;
              border: 3px solid white;
              box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            "></div>`,
            iconSize: [24, 24],
            iconAnchor: [12, 12],
          });

          L.marker([neighbourhood.lat, neighbourhood.lng], { icon: markerIcon }).addTo(map);

          // Load isochrone data from cache
          const data = isochroneCache[neighbourhood.name];

          if (!data) {
            continue; // Skip if no cache for this neighbourhood
          }

          // Add isochrone polygons (reverse order so smaller ones are on top)
          const features = [...data.features].reverse();

          features.forEach((feature, featureIndex) => {
            if (!mapInstanceRef.current) return;

            const coords = feature.geometry.coordinates[0].map(
              (coord: number[]) => [coord[1], coord[0]] as [number, number]
            );

            // Use custom colors based on which neighbourhood (primary vs secondary)
            // featureIndex 0 = 5min (innermost), 1 = 10min, 2 = 15min (outermost)
            const fillColor = scheme.colors[featureIndex] || scheme.colors[0];

            L.polygon(coords, {
              fillColor,
              fillOpacity: 0.2,
              color: fillColor,
              weight: 2,
              opacity: 0.7,
            }).addTo(mapInstanceRef.current);
          });

          // Collect bounds
          if (data.features.length > 0) {
            const outerFeature = data.features[0];
            const coords = outerFeature.geometry.coordinates[0].map(
              (coord: number[]) => [coord[1], coord[0]] as [number, number]
            );
            allBounds.push(L.latLngBounds(coords));
          }
        }

        // Fit map to combined bounds of all isochrones
        if (allBounds.length > 0 && mapInstanceRef.current) {
          let combinedBounds = allBounds[0];
          for (let i = 1; i < allBounds.length; i++) {
            combinedBounds = combinedBounds.extend(allBounds[i]);
          }
          mapInstanceRef.current.fitBounds(combinedBounds, { padding: [30, 30] });
        }

        setIsLoading(false);
      } catch (err) {
        console.error("Isochrone load error:", err);
        setError("Could not load walking radius");
        setIsLoading(false);
      }
    };

    loadIsochrones();

    return () => {
      if (mapInstanceRef.current) {
        mapInstanceRef.current.remove();
        mapInstanceRef.current = null;
      }
    };
  }, [neighbourhoods]);

  const primaryNeighbourhood = neighbourhoods[0];
  const secondaryNeighbourhood = neighbourhoods[1];

  return (
    <div className="relative w-full h-full min-h-[300px] rounded-xl overflow-hidden">
      <div ref={mapRef} className="w-full h-full min-h-[300px]" />

      {/* Loading overlay */}
      {isLoading && (
        <div className="absolute inset-0 bg-white/80 flex items-center justify-center z-[1000]">
          <div className="flex flex-col items-center gap-2">
            <div className="w-8 h-8 border-3 border-primary border-t-transparent rounded-full animate-spin" />
            <span className="text-sm text-gray-600">Loading walking radius...</span>
          </div>
        </div>
      )}

      {/* Error overlay */}
      {error && (
        <div className="absolute inset-0 bg-white/90 flex items-center justify-center z-[1000]">
          <p className="text-sm text-red-500">{error}</p>
        </div>
      )}

      {/* Legend */}
      {!isLoading && !error && (
        <div className="absolute bottom-3 left-3 bg-white/95 backdrop-blur-sm rounded-lg px-3 py-2 shadow-md z-[1000]">
          {/* Primary Legend */}
          {primaryNeighbourhood && (
            <div className="mb-2">
              <p className="text-xs font-medium text-gray-700 mb-1">{primaryNeighbourhood.name}</p>
              <div className="flex flex-col gap-0.5">
                <div className="flex items-center gap-2">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "#6366f1" }} />
                  <span className="text-[10px] text-gray-600">5 min</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "#a855f7" }} />
                  <span className="text-[10px] text-gray-600">10 min</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "#ec4899" }} />
                  <span className="text-[10px] text-gray-600">15 min</span>
                </div>
              </div>
            </div>
          )}

          {/* Secondary Legend */}
          {secondaryNeighbourhood && (
            <div className={primaryNeighbourhood ? "pt-2 border-t border-gray-200" : ""}>
              <p className="text-xs font-medium text-gray-700 mb-1">{secondaryNeighbourhood.name}</p>
              <div className="flex flex-col gap-0.5">
                <div className="flex items-center gap-2">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "#10b981" }} />
                  <span className="text-[10px] text-gray-600">5 min</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "#14b8a6" }} />
                  <span className="text-[10px] text-gray-600">10 min</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: "#06b6d4" }} />
                  <span className="text-[10px] text-gray-600">15 min</span>
                </div>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
